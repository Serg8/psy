{"version":3,"sources":["components/Develop/Develop.module.scss","components/Header/Header.module.scss","components/Footer/Footer.module.scss","components/Header/Header.tsx","components/Footer/Footer.tsx","components/Develop/Develop.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Header","className","classes","header","Footer","footer","Develop","useState","editMode","setEditMode","status","setStatus","useEffect","console","log","Math","trunc","random","counter","setCounter","title","date","Date","now","state","setState","setData","x","y","pos","setPos","type","setType","fetch","then","response","json","window","addEventListener","event","clientX","clientY","value","renderCount","useRef","inputRef","prevValue","current","wrapperDevelop","onDoubleClick","onChange","e","currentTarget","autoFocus","onBlur","onClick","prevCounter","btn","btnSuccess","btnDelete","prev","btnDefault","JSON","stringify","ref","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.ee79bd6e.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"wrapperDevelop\":\"Develop_wrapperDevelop__3tML0\",\"btn\":\"Develop_btn__1nRe7\",\"btnSuccess\":\"Develop_btnSuccess__15ewL\",\"btnDelete\":\"Develop_btnDelete__2hRSu\",\"btnDefault\":\"Develop_btnDefault__1-R8M\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"Header_header__1v0yI\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"footer\":\"Footer_footer__7dIj9\"};","import React from 'react';\nimport classes from './Header.module.scss';\n\nconst Header = () => {\n  return (\n    <header className={classes.header}>\n      <div>logo</div>\n      <nav>\n        <ul>\n          <li>Home</li>\n        </ul>\n      </nav>\n    </header>\n  );\n};\n\nexport default Header;\n","import React from 'react';\nimport classes from './Footer.module.scss';\n\nconst Footer = () => {\n  return <footer className={classes.footer}>FOOTER</footer>;\n};\n\nexport default Footer;\n","import React, { useEffect, useState, useRef } from 'react';\nimport classes from './Develop.module.scss';\n\nconst Develop = () => {\n  ///====useState===========================\n\n  // let array = useState(false); // это значение не храниться локально, тк. функция не имеет стэйта,\n  // значение хранится на стороне реакта // array = тут только одно значение и одна функция т.е. 2 элемента\n  // let editMode = array[0]; // здесь начальное значение, те false, который мы задали на строке выше\n  //  let setEditMode = array[1]; // здесь функция, которая изменяет первое одиночное значение\n\n  // деструктурированное присваивание\n  const [editMode, setEditMode] = useState(false);\n  const [status, setStatus] = useState('start'); // если нужно, то добавляем ещё один стэйт\n  // получаем два разных состояния, которые меняются независимо друг от друга\n\n  useEffect(() => {\n    //setStatus(props.status);\n  }, []); // [] -  реакт, запускай useEffect не всегда, а только тогда, когда компонента вмонтировалась первый раз\n  // вообще не правильно закидывать пустой массив в useEffect, нужно чтобы он срабатывал, когда ещё приходят пропсы\n  // указываем в массивые зависимость от props.status те. [props.status],\n  // таким образом, елси при очередной перерисовки, props.status будет другим, то запустится useEffect\n\n  const activateEditMode = () => {\n    setEditMode(true); // setEditMode - это второе значение, которым является функция\n  };\n\n  const deactivateEditMode = () => {\n    setEditMode(false);\n  };\n\n  const onStatusChange = (e: any) => {\n    setStatus(e.currentTarget.value);\n  };\n\n  // методов жизненного цикла в хуках нет\n\n  // =============================================================================================\n\n  const computeInitialCounter = () => {\n    console.log('same calculations ...');\n    return Math.trunc(Math.random() * 20);\n  };\n\n  const [counter, setCounter] = useState(() => {\n    return computeInitialCounter();\n  });\n  // hook useState нельзя использовать внутри условий if\n  // hook работает асинхронно\n  // можно использовать callBack функцию, чтобы оптимизировать performance, чтобы функция computeInitialCounter\n  // не вызывалась каждый раз при рендеренге\n\n  // формат объект\n  const [state, setState] = useState({\n    title: 'Счётчик',\n    date: Date.now(),\n  });\n\n  const increment = () => {\n    //setCounter(counter + 1);\n    setCounter((prevCounter) => {\n      return prevCounter + 1;\n    });\n    // setCounter( prev => prev + 1);\n  };\n\n  const decrement = () => {\n    setCounter(counter - 1);\n  };\n\n  const changeTitle = () => {\n    setState((prev) => {\n      return {\n        ...prev,\n        title: 'new title',\n      };\n    });\n  };\n\n  ///====useState=========end==================\n  ///====useEffect=========start==================\n\n  const [data, setData] = useState([]);\n  const [pos, setPos] = useState({\n    x: 0,\n    y: 0,\n  });\n\n  // interface UserData {\n  //     username: string;\n  //     password: string;\n  //     prevState: 'users'\n  // }\n\n  // let type: string, setType: any;\n  const [type, setType] = useState(`users`);\n\n  const todos = () => {\n    setType('todos');\n  };\n  const posts = () => {\n    setType('posts');\n  };\n  const users = () => {\n    setType('users');\n  };\n\n  // useEffect вызывается каждый раз, когда происходит рендер\n  // useEffect(() => {\n  //     console.log('render');\n  // });\n\n  useEffect(() => {\n    fetch(`https://jsonplaceholder.typicode.com/${type}`)\n      .then((response) => response.json())\n      .then((json) => setData(json));\n\n    return () => {\n      console.log('clean type');\n    };\n  }, [type]); // указываем зависимоть useEffect от deps, чтобы он срабатывал только тогда, когда deps изменился\n\n  useEffect(() => {\n    console.log('ComponentDidMount');\n\n    window.addEventListener('mousemove', (event) => {\n      setPos({\n        x: event.clientX,\n        y: event.clientY,\n      });\n    });\n  }, []); // тк пустой массив в списке зависимостей, то этот useEffect сработает только один первый раз, как ComponentDidMount\n\n  ///====useEffect=========end==================\n  ///====useRef=========start==================\n\n  //const [renderCount, setRenderCount] = useState(1);\n  const [value, setValue] = useState('initial');\n  const renderCount = useRef(1);\n  const inputRef = useRef(null);\n  const prevValue = useRef('');\n\n  useEffect(() => {\n    //setRenderCount(prev => prev + 1)\n    renderCount.current++;\n  });\n\n  useEffect(() => {\n    prevValue.current = value;\n  }, [value]);\n\n  const focus = () => {};\n\n  ///====useRef=========end==================\n  ///====use=========start==================\n\n  return (\n    <div className={classes.wrapperDevelop}>\n      <h1>hook useState</h1>\n      <div>\n        <h2>Change status</h2>\n        {!editMode && (\n          <div>\n            <span onDoubleClick={activateEditMode}>botton</span>{' '}\n            <div>status: {status}</div>\n          </div>\n        )}\n        {editMode && (\n          <div>\n            <input\n              onChange={onStatusChange}\n              autoFocus={true}\n              onBlur={deactivateEditMode}\n              value={status}\n            />\n          </div>\n        )}\n      </div>\n\n      <div>\n        <h2>Counter: {counter}</h2>\n        <button onClick={increment} className={`${classes.btn} ${classes.btnSuccess}`}>\n          Add\n        </button>\n        <button onClick={decrement} className={`${classes.btn} ${classes.btnDelete}`}>\n          Remove\n        </button>\n        <button onClick={changeTitle} className={`${classes.btn} ${classes.btnDefault}`}>\n          Change title\n        </button>\n\n        <pre>{JSON.stringify(state, null, 2)}</pre>\n      </div>\n\n      <hr />\n      <hr />\n      <h1>hook useEffect</h1>\n\n      <h2>Ресурс: {type}</h2>\n      <button onClick={users} className={`${classes.btn} ${classes.btnDefault}`}>\n        Пользователи\n      </button>\n      <button onClick={todos} className={`${classes.btn} ${classes.btnDefault}`}>\n        toDos\n      </button>\n      <button onClick={posts} className={`${classes.btn} ${classes.btnDefault}`}>\n        Посты\n      </button>\n\n      {/*<pre>{JSON.stringify(data, null, 2)}</pre>*/}\n      <pre>{JSON.stringify(pos, null, 2)}</pre>\n\n      <hr />\n      <hr />\n      <h1>hook useRef</h1>\n      <div>Количество рендеров - {renderCount.current}</div>\n      <div>Прошлое состояние - {prevValue.current}</div>\n      <input type=\"text\" ref={inputRef} value={value} />\n      <button className={classes.btnDefault} onClick={focus}>\n        focus\n      </button>\n    </div>\n  );\n};\n\nexport default Develop;\n","import React from 'react';\nimport Header from './components/Header/Header';\nimport Footer from './components/Footer/Footer';\nimport Develop from './components/Develop/Develop';\n\nfunction App() {\n  return (\n    <div>\n      <Header />\n      <Develop />\n      <Footer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}